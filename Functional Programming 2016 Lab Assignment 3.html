<!DOCTYPE html>
<!-- saved from url=(0075)http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><link rel="stylesheet" href="./Functional Programming 2016 Lab Assignment 3_files/lab3.css" title="FP">
<link rel="prev" href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/2/" title="Lab 2">
<link rel="next" href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/4/" title="Lab 4">
<meta name="viewport" content="width = device-width">






<title>Functional Programming 2016 Lab Assignment 3</title>
</head><body><header>
<div class="codes">
  TDA 452
  <br>DIT 142
  <br>HT&nbsp;2016
</div>
<h1>
<a href="http://www.haskell.org/"><img title="Haskell Logo" src="./Functional Programming 2016 Lab Assignment 3_files/Haskell-Logo.svg" alt=""></a>
Functional Programming 2016
<br><small>Lab Assignment 3</small></h1>
</header>


<nav>
<ul>
  <li><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/">Home</a> </li><li> &gt;
  </li><li><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/#labs">Labs</a> </li><li> &gt;
  </li><li>Lab 3
</li></ul>
</nav>

<main>

<p>Some notes:

</p><ul>
<li><p>Remember that you have to work in pairs. <b>Only groups of size 2 are allowed to submit!</b> Submissions by only 1 person or 3 or more persons
will not be accepted by the Fire system.
</p></li><li><p><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/fire.shtml">When you are done, 
please submit your solution using the Fire system.</a>
</p></li><li><p>If you are stuck on this assignment, please read the page on <a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/help.shtml">Getting Help</a> carefully!
</p></li></ul>
Good luck!

<h2>Lab Assignment 3: Sudoku</h2>

In this Lab Assignment, you will design a Haskell program that will be able
to solve Sudokus, a popular logical puzzle originating from Japan.

<h3>Assignments and Deadlines</h3>

There are 6 regular assignments as part of this Lab: A, B, C, D, E, and F. The
lab consists (again) of two parts.

<p>For submission, assignments A, B, C and D are called <b>Lab 3A</b>. 

</p><p>Assignments E and F are called <b>Lab 3B</b>. 

</p><p>
Deadlines for each of these parts are given on
the <a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/#labs">home page</a>.

There are also <a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/extra.shtml">extra assignments</a>. You can choose freely
whether to do one of these. Those are just for fun. 

</p><h3>Hints</h3>

Some assignments have hints. Often, these involve particular standard Haskell
functions that you could use. Some of these functions are defined in modules
that you have to import yourself explicitly. You can use the following
resources to find more information about those functions:

<ul>
  <li><p><a href="http://www.haskell.org/hoogle/">Hoogle</a>,
  the library function search engine
  </p></li><li><p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries/index.html">Haskell Hierarchical Libraries</a>,
  all the library modules, included with the latest version of GHC.
"Modules")
  </p></li><li><p><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/tourofprelude.html">A Tour of the Haskell Prelude</a>
  shows standard Haskell functions that you get without importing any module.
</p></li></ul>

We encourage you to actually go and find information about the functions that
are mentioned in the hints!

<!-- ==================================================================== -->

<h2>Sudokus</h2>

Sudoku is a logic puzzle originating in Japan. In the West
it has caught on in popularity enormously over the last five years or so. Most
newspapers now publish a daily Sudoku puzzle for the readers to solve.

<p>
A Sudoku puzzle consists of a 9x9 grid. Some of the cells in the grid have
digits (from 1 to 9), others are blank. The objective of the puzzle is to fill
in the blank cells with digits from 1 to 9, in such a way that every row, every
column and every 3x3 block has exactly one occurrence of each digit 1 to 9.


</p><div class="center">
  <table class="sudoku">
    <caption>Here is an example of a Sudoku puzzle</caption>
  <tbody><tr><td>3</td><td>6</td><td>  </td><td>  </td><td>7</td><td>1</td><td>2</td><td>  </td><td>  
  </td></tr><tr><td>  </td><td>5</td><td>  </td><td>  </td><td>  </td><td>  </td><td>1</td><td>8</td><td>  
  </td></tr><tr><td>  </td><td>  </td><td>9</td><td>2</td><td>  </td><td>4</td><td>7</td><td>  </td><td>  
  </td></tr><tr><td>  </td><td>  </td><td>  </td><td>  </td><td>1</td><td>3</td><td>  </td><td>2</td><td>8
  </td></tr><tr><td>4</td><td>  </td><td>  </td><td>5</td><td>  </td><td>2</td><td>  </td><td>  </td><td>9
  </td></tr><tr><td>2</td><td>7</td><td>  </td><td>4</td><td>6</td><td>  </td><td>  </td><td>  </td><td>  
  </td></tr><tr><td>  </td><td>  </td><td>5</td><td>3</td><td>  </td><td>8</td><td>9</td><td>  </td><td>  
  </td></tr><tr><td>  </td><td>8</td><td>3</td><td>  </td><td>  </td><td>  </td><td>  </td><td>6</td><td>  
  </td></tr><tr><td>  </td><td>  </td><td>7</td><td>6</td><td>9</td><td>  </td><td>  </td><td>4</td><td>3
</td></tr></tbody></table>

<table class="sudoku">
  <caption>Here is the solution to the Sudoku puzzle</caption>
  <tbody><tr><th>3</th><th>6</th><td>4</td><td>8</td><th>7</th><th>1</th><th>2</th><td>9</td><td>5
  </td></tr><tr><td>7</td><th>5</th><td>2</td><td>9</td><td>3</td><td>6</td><th>1</th><th>8</th><td>4
  </td></tr><tr><td>8</td><td>1</td><th>9</th><th>2</th><td>5</td><th>4</th><th>7</th><td>3</td><td>6
  </td></tr><tr><td>5</td><td>9</td><td>6</td><td>7</td><th>1</th><th>3</th><td>4</td><th>2</th><th>8
  </th></tr><tr><th>4</th><td>3</td><td>1</td><th>5</th><td>8</td><th>2</th><td>6</td><td>7</td><th>9
  </th></tr><tr><th>2</th><th>7</th><td>8</td><th>4</th><th>6</th><td>9</td><td>3</td><td>5</td><td>1
  </td></tr><tr><td>6</td><td>4</td><th>5</th><th>3</th><td>2</td><th>8</th><th>9</th><td>1</td><td>7
  </td></tr><tr><td>9</td><th>8</th><th>3</th><td>1</td><td>4</td><td>7</td><td>5</td><th>6</th><td>2
  </td></tr><tr><td>1</td><td>2</td><th>7</th><th>6</th><th>9</th><td>5</td><td>8</td><th>4</th><th>3
</th></tr></tbody></table>
</div>

<p>
In this lab assignment, you will write a Haskell program that can read in a
Sudoku puzzle and solve it.

</p><h3>More Information</h3>

If you want to read more about Sudokus, here are a few links:

<ul>
<li><p>The <a href="http://www.dailysudoku.com/sudoku/index.shtml">Daily Sudoku</a> has examples and explanations.
</p></li><li><p><a href="http://en.wikipedia.org/wiki/Sudoku">Wikipedia on Sudoku</a>.
</p></li><li><p><a href="http://www.sudoku.com/">sudoku.com</a> has examples and
explanations.
</p></li><li><p><a href="http://sudoku.com.au/">sudoku.com.au</a> has sudoku
puzzles that you can solve online.
</p></li></ul>

<p>

<!-- ==================================================================== -->

</p><h2>Modelling Sudokus</h2>


To implement a Sudoku-solving program, we need to come up with a way of
modelling Sudokus. A Sudoku is a matrix of digits or blanks. The natural way of
modelling a matrix is as a list of lists. The outer list represents all the
rows, and the elements of the list are the elements of each row. Digits or
blanks can be represented by using the Haskell <code>Maybe</code> type. Digits are
simply represented by <code>Int</code>.

<p>

Summing up, a natural way to represent Sudokus is using the following Haskell
datatype:

</p><pre><b>data</b> Sudoku = Sudoku [[Maybe Int]]</pre>

Since it is convenient to have a function that extracts the actual rows from the
Sudoku, we actually use the following equivalent datatype definition:

<pre><b>data</b> Sudoku = Sudoku { rows :: [[Maybe Int]] }</pre>

For example, the above Sudoku puzzle has the following representation in Haskell:

<pre>example :: Sudoku
example =
  Sudoku
    [ [Just 3, Just 6, Nothing,Nothing,Just 7, Just 1, Just 2, Nothing,Nothing]
    , [Nothing,Just 5, Nothing,Nothing,Nothing,Nothing,Just 1, Just 8, Nothing]
    , [Nothing,Nothing,Just 9, Just 2, Nothing,Just 4, Just 7, Nothing,Nothing]
    , [Nothing,Nothing,Nothing,Nothing,Just 1, Just 3, Nothing,Just 2, Just 8]
    , [Just 4, Nothing,Nothing,Just 5, Nothing,Just 2, Nothing,Nothing,Just 9]
    , [Just 2, Just 7, Nothing,Just 4, Just 6, Nothing,Nothing,Nothing,Nothing]
    , [Nothing,Nothing,Just 5, Just 3, Nothing,Just 8, Just 9, Nothing,Nothing]
    , [Nothing,Just 8, Just 3, Nothing,Nothing,Nothing,Nothing,Just 6, Nothing]
    , [Nothing,Nothing,Just 7, Just 6, Just 9, Nothing,Nothing,Just 4, Just 3]
    ]
</pre>
or, written in a more compact way:
<pre>example :: Sudoku
example =
    Sudoku
      [ [j 3,j 6,n  ,n  ,j 7,j 1,j 2,n  ,n  ]
      , [n  ,j 5,n  ,n  ,n  ,n  ,j 1,j 8,n  ]
      , [n  ,n  ,j 9,j 2,n  ,j 4,j 7,n  ,n  ]
      , [n  ,n  ,n  ,n  ,j 1,j 3,n  ,j 2,j 8]
      , [j 4,n  ,n  ,j 5,n  ,j 2,n  ,n  ,j 9]
      , [j 2,j 7,n  ,j 4,j 6,n  ,n  ,n  ,n  ]
      , [n  ,n  ,j 5,j 3,n  ,j 8,j 9,n  ,n  ]
      , [n  ,j 8,j 3,n  ,n  ,n  ,n  ,j 6,n  ]
      , [n  ,n  ,j 7,j 6,j 9,n  ,n  ,j 4,j 3]
      ]
  where
    n = Nothing
    j = Just
</pre>

Now, a number of assignments follows, which will lead you step-by-step towards
an implementation of a Sudoku-solver.

<!-- ==================================================================== -->

<h2>Some Basic Sudoku Functions</h2>

To warm up, we start with a number of basic functions on Sudukos.

<h3>Assignment A</h3>

<div class="assignment">
<b>A1.</b> Implement a function

  <pre>allBlankSudoku :: Sudoku</pre>
  
that represents a Sudoku that only contains blank cells (this means that no
digits are present).
<p>
Do not use copy-and-paste programming here! Your definition does not need to be longer than
a few short lines.
</p></div>

<div class="assignment">
<b>A2.</b> The Sudoku type we have defined allows for more things than Sudokus.
For example, there is nothing in the type definition that says that a
Sudoku has 9 rows and 9 columns,
or that digits need to lie between 1 and 9. Implement a function
  
  <pre>isSudoku :: Sudoku -&gt; Bool</pre>
  
that checks if all such extra conditions are met by the given Sudoku.
<p>
Examples:
</p><pre class="interactive"><code>isSudoku (Sudoku [])</code>
False
<code>isSudoku allBlankSudoku</code>
True
<code>isSudoku example</code>
True
<code>isSudoku (Sudoku (tail (rows example)))</code>
False
</pre>
</div>

<div class="assignment">
<b>A3.</b> Our job is to solve Sudokus. So, it would be handy to know
when a Sudoku is solved or not. We say that a Sudoku is solved if there
are no blank cells left to be filled in anymore. Implement the following
function:

  <pre>isSolved :: Sudoku -&gt; Bool</pre>
  
Note that we do not check here if the Sudoku is a <em>valid</em> solution; we
will do this later. This means that any Sudoku without blanks (even Sudokus with
the same digit appearing twice in a row) is considered
solved by this function!
</div>

<h3>Hints</h3>

To implement the above, use list comprehensions! Also, the following standard
Haskell functions might come in handy:

<pre>replicate :: Int -&gt; a -&gt; [a]
length    :: [a] -&gt; Int
and       :: [Bool] -&gt; Bool
</pre>

To help you get started, here is a file that you can use:

<ul>
<li><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/Sudoku.hs">Sudoku.hs</a>, with some definitions that help you
get going with Assignments A, B and C.
</li></ul>

<!-- ==================================================================== -->

<h2>Reading and Printing Sudokus</h2>

Next, we need to have a way of representing Sudokus in a file. In that way, our
program can read Sudokus from a file, and it is easy for us to create and store
several Sudoku puzzles.

<p>
The following is an example text-representation that we will use in this
assignment. It actually represents the example above.

</p><pre>36..712..
.5....18.
..92.47..
....13.28
4..5.2..9
27.46....
..53.89..
.83....6.
..769..43
</pre>

There are 9 lines of text in this representation, each corresponding to a row.
Each line contains 9 characters. A digit 1 -- 9 represents a filled cell, and a
period (.) represents a blank cell.

<h3>Assignment B</h3>

<div class="assignment">
  <b>B1.</b> Implement a function:
  
  <pre>printSudoku :: Sudoku -&gt; IO ()</pre>
  
  that, given a Sudoku, creates instructions to print the Sudoku on the screen,
  using the format shown above.
<p>
Example:
</p><pre class="interactive"><code>printSudoku allBlankSudoku</code>
.........
.........
.........
.........
.........
.........
.........
.........
.........
</pre>
<pre class="interactive"><code>printSudoku example</code>
36..712..
.5....18.
..92.47..
....13.28
4..5.2..9
27.46....
..53.89..
.83....6.
..769..43
</pre>
</div>

<div class="assignment">
<b>B2.</b> Implement a function:

  <pre>readSudoku :: FilePath -&gt; IO Sudoku</pre>
  
that, given a filename, creates instructions that read the Sudoku from the
file, and deliver it as the result of the instructions. You may decide yourself
what to do when the file does not contain a representation of a Sudoku.
<p>
Examples:
</p><pre class="interactive"><code>sud &lt;- readSudoku "example.sud"</code>
<code>printSudoku sud</code>
36..712..
.5....18.
..92.47..
....13.28
4..5.2..9
27.46....
..53.89..
.83....6.
..769..43
<code>readSudoku "Sudoku.hs"</code>
Program error: Not a Sudoku!
</pre>
</div>

<p>

</p><h3>Hints</h3>

<p>
To implement the above, you will need to be able to convert between characters
(type <code>Char</code>) and digits/integers (type <code>Int</code>). The standard functions
<code>chr</code> and <code>ord</code> (import the module <code>Data.Char</code>) will come in handy
here. Think about the following problems:
</p><ul>
<li>Given a character representing a digit, for example '3' :: Char. How do you compute
the integer value 3?
</li><li>Given a digit represented as an integer, for example 3 :: Int. How do
you compute the character '3'?
</li></ul>
The constant value <code>ord '0'</code> will play a central role in all this.

<p>
Here are some functions that might come in handy:

</p><pre>chr       :: Int -&gt; Char
ord       :: Char -&gt; Int
putStr    :: String -&gt; IO ()
putStrLn  :: String -&gt; IO ()
sequence_ :: [IO a] -&gt; IO ()
readFile  :: FilePath -&gt; IO String
lines     :: String -&gt; [String]
</pre>

Here are some example Sudoku-files that you can download and use:

<ul>
<li><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/example.sud">example.sud</a>, containing the above example.
</li><li><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/sudokus.zip">sudokus.zip</a>, a ZIPped collection of sudokus,
both easy and hard ones. The easy ones should all be solvable by your final program
within minutes; the hard ones will probably take a very long time (unless you do
extra Assignment X and/or Y)!.
</li></ul>

<!-- ==================================================================== -->

<h2>Generating Sudokus as Test Data</h2>

Finally, we need to be able to test properties about the functions related to
our Sudokus. In order to do so, QuickCheck needs to be able to generate
arbitrary Sudokus.

<p>

Let us split this problem into a number of smaller problems. First, we need to
know how to generate arbitrary cell values (of type <code>Maybe Int</code>). Then,
we need to know how to generate 81 such cells, and compose them all into a
Sudoku.

</p><h3>Assignment C</h3>

<div class="assignment">
<b>C1.</b> Implement a function:

  <pre>cell :: Gen (Maybe Int)</pre>
  
that, contains instructions for generating a Sudoku cell. You have to think
about the following:
<ul>
<li>Cells either contain a digit between 1 and 9 (for example <code>Just 3</code>) or
are empty (<code>Nothing</code>),
</li><li>We would like our generated Sudokus to resemble realistic Sudoku puzzles.
Therefore, the distribution should be around 10% probability non-empty cells
vs. 90% probability for empty cells. (This is not something strict; you can play
around with this if you like.)
</li></ul>
<p>
Example:
</p><pre class="interactive"><code>sample cell</code>
Just 3
Nothing
Nothing
Just 7
Nothing
</pre>
</div>


<div class="assignment">
<b>C2.</b> Make Sudokus an instance of the class Arbitrary.
<pre><b>instance</b> Arbitrary Sudoku <b>where</b>
  ...
</pre>
We have already done this for you in the file
<a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/Sudoku.hs">Sudoku.hs</a>.
</div>

<div class="assignment">
<b>C3.</b> Define a property
  
<pre>prop_Sudoku :: Sudoku -&gt; Bool</pre>
  
that expresses that each generated Sudoku actually is a Sudoku according to
Assignment A2. Also use QuickCheck to check that the property 
actually holds for all Sudokus that are generated.
</div>

<h3>Hints</h3>

Here are some functions that might come in handy:

<pre>sample    :: Show a =&gt; Gen a -&gt; IO ()
choose    :: Random a =&gt; (a,a) -&gt; Gen a
frequency :: [(Int,Gen a)] -&gt; Gen a
sequence  :: [Gen a] -&gt; Gen [a]
</pre>

You might want to take a look at the lecture notes and example code on test data
generation.

<!-- ==================================================================== -->

<h2>Rows, Columns, Blocks</h2>

Now, we are going to think about what actually constitutes a valid solution of a
Sudoku. There are three constraints that a valid solution has to forfill:

<ul>
<li>No row can contain the same digit twice;
</li><li>No column can contain the same digit twice;
</li><li>No 3x3 block can contain the same digit twice.
</li></ul>

This leads us to the definition of a <em>block</em>; a block is either a row or
a column or a 3x3 block. A block therefore contains 9 cells:

<pre><b>type</b> Block = [Maybe Int]</pre>

We are going to define a function that checks if a Sudoku is not violating any
of the above constraints, by checking that none of the blocks violate those
constraints.

<h3>Assignment D</h3>

<div class="assignment">
<b>D1.</b> Implement a function:

  <pre>isOkayBlock :: Block -&gt; Bool</pre>
  
that, given a block, checks if that block does not contain the same digit twice.
<p>
Examples:
</p><pre class="interactive"><code>isOkayBlock [Just 1, Just 7, Nothing, Nothing, Just 3, Nothing, Nothing, Nothing, Just 2]</code>
True
<code>isOkayBlock [Just 1, Just 7, Nothing, Just 7, Just 3, Nothing, Nothing, Nothing, Just 2]</code>
False
</pre>
</div>

<div class="assignment">
<b>D2.</b> Implement a function:

  <pre>blocks :: Sudoku -&gt; [Block]</pre>
  
that, given a Sudoku, creates a list of all blocks of that Sudoku. This means:
<ul>
<li>9 rows,
</li><li>9 columns,
</li><li>9 3x3 blocks.
</li></ul>
<p>
Also add a property that states that, for each Sudoku, there are 3*9 blocks,
and each block has exactly 9 cells.
</p></div>

<div class="assignment">
<b>D3.</b> Now, implement a function:

  <pre>isOkay :: Sudoku -&gt; Bool</pre>
  
that, given a Soduko, checks that all rows, colums and 3x3 blocks do not contain
the same digit twice.
<p>
Examples:
</p><pre class="interactive"><code>isOkay allBlankSudoku</code>
True
<code>sud &lt;- readSudoku "example.sud"</code>
<code>isOkay sud</code>
True
</pre>
</div>

<h3>Hints</h3>

Here are some functions that might come in handy:

<pre>nub       :: Eq a =&gt; [a] -&gt; [a]
transpose :: [[a]] -&gt; [[a]]
take      :: Int -&gt; [a] -&gt; [a]
drop      :: Int -&gt; [a] -&gt; [a]
</pre>

Note that some of the above functions only appear when you import
<code>Data.List</code>.

<p>
You might want to take a look at the exercises and answers on lists and list
comprehensions.

<!-- ==================================================================== -->

</p><h2>Positions and Finding Blanks</h2>

We are getting closer to the final solving function. Let us start thinking about
how such a function would work.

<p>
Given a Sudoku, if there are no blanks left in the Sudoku, we are done.
Otherwise, there is at least one blank cell that needs to be filled in somehow.
We are going to write functions to find and manipulate blank cells.

</p><p>
It is quite natural to start to talk about <em>positions</em>. A position is a
coordinate that identifies a cell in the Sudoku. Here is a way of modelling
coordinates:

</p><pre><b>type</b> Pos = (Int,Int)</pre>

We use positions as indicating first the row and then the column.
For example, the position (3,5) denotes the 5th cell in the 3rd row.

<p>
Note: It is common in programming languages to start counting at 0! Therefore,
the position that indicates the upper left corner is (0,0), and the position
indicating the lower right corner is (8,8).

</p><h3>Assignment E</h3>

<div class="assignment">
<b>E1.</b> Implement a function:

  <pre>blanks :: Sudoku -&gt; [Pos]</pre>
  
that, given a Sudoku  returns a list of the positions in the
Sudoku that are still blank. You may decide on the order in which the 
positions appear.
<p>
Examples:
</p><pre class="interactive"><code>length (blanks allBlankSudoku) == 9*9</code>
True
<code>blanks example</code>
[(0,2),(0,3),(0,7),(0,8),(1,0),(1,2),(1,3),(1,4),(1,5),(1,8),(2,0),(2,1),
 (2,4),(2,7),(2,8),(3,0),(3,1),(3,2),(3,3),(3,6),(4,1),(4,2),(4,4),(4,6),
 (4,7),(5,2),(5,5),(5,6),(5,7),(5,8),(6,0),(6,1),(6,4),(6,7),(6,8),(7,0),
 (7,3),(7,4),(7,5),(7,6),(7,8),(8,0),(8,1),(8,5),(8,6)]
</pre>
<p>In addition, write a property that states that all cells in the blanks list 
are actually blank.
</p></div>

<div class="assignment">
<b>E2.</b> Implement a function:
<pre>(!!=) :: [a] -&gt; (Int,a) -&gt; [a]</pre>
that, given a list, and a tuple containing an index in the list and a new value,
updates the given list with the new value at the given index.
<p>
Examples:
</p><pre class="interactive"><code>["a","b","c","d"] !!= (1,"apa")</code>
["a","apa","c","d"]
<code>["p","qq","rrr"] !!= (0,"bepa")</code>
["bepa","qq","rrr"]
</pre>
<p>Also write (a) propert(y/ies) that state(s) the expected properties of this
function. Think about what can go wrong!
</p></div>

<div class="assignment">
<b>E3.</b> Implement a function:
  
  <pre>update :: Sudoku -&gt; Pos -&gt; Maybe Int -&gt; Sudoku</pre>
  
that, given a Sudoku, a position, and a new cell value, updates the given Sudoku
at the given position with the new value.
<p>
Example:
</p><pre class="interactive"><code>printSudoku (update allBlankSudoku (1,3) (Just 5))</code>
.........
...5.....
.........
.........
.........
.........
.........
.........
.........
</pre>
<p>Also write a property that checks that the updated position really has gotten
the new value.
</p></div>

<div class="assignment">
  <b>E4.</b> Implement a function:
  
  <pre>candidates :: Sudoku -&gt; Pos -&gt; [Int]</pre>
  
that, given a Sudoku, and a blank position, determines which numbers could be
legally written into that position.
<p>
Example:
</p><pre class="interactive"><code>candidates example (0,2)</code>
[4,8]
<code>candidates allBlankSudoku (8,8)</code>
[1,2,3,4,5,6,7,8,9]
</pre>
<p>In addition, write a property that relates the function candidates with the functions update, isSudoku, and isOkay. (This property can be very useful to understand how to solve Sudokus!)
</p></div>

<h3>Hints</h3>

There is a standard function <code>(!!)</code> in Haskell for getting a specific
element from a list. It starts indexing at 0, so for example to get the
first element from a list xs, you can use xs !! 0.

<p>

We usually use the standard function <code>zip</code> to pair up elements in a list
with their corresponding index. Example:
</p><pre class="interactive"><code>["apa","bepa","cepa"] `zip` [1..3]</code>
[("apa",1),("bepa",2),("cepa",3)]
</pre>
This, in combination with list comprehensions, should be very useful for this
assignment!

<p>

When testing a property that is polymorphic (meaning that it has type variables
in its type), you need to add a type signature that picks an arbitrary type. For
example, when testing properties for the function (!!=), which works for lists
of any type, you have to fix the type when testing, for example lists of
Integers. Do this by adding a type signature to your properties.

</p><p>

Here are some more useful functions:

</p><pre>head :: [a] -&gt; a
(!!) :: [a] -&gt; Int -&gt; a
zip  :: [a] -&gt; [b] -&gt; [(a,b)]
</pre>


<!-- ==================================================================== -->

<h2>Solving Sudokus</h2>

Finally, we have all the bits in place to attack our main problem: Solving a
given Sudoku.

<p>

Our objective is to define a Haskell function

</p><pre>solve :: Sudoku -&gt; Maybe Sudoku</pre>

The basic idea is as follows. Function solve must first check that its argument
is not already a bad Sudoku. This means that (1) it represents a 9x9 sudoku, (2) it has no blocks
(rows, columns, 3x3 blocks) that contain the same digit twice.
We will only do this check once. If the argument is bad then 
solve must return <code>Nothing</code>
<p>
Now if we have such a Sudoku <code>sud</code> that we would like to solve, we give it to a recursive helper function <code>solve'</code>. 
</p><p>
The <code>solve'</code> function must 
consider all the blanks in <code>sud</code>. If this list is empty then 
by (1) and (2) above we are done, and the answer of <code>solve'</code> (and hence <code>solve</code>) 
must be <code>Just sud</code>. 
</p><p> 
Otherwise there is at least one blank position. We choose one of them. 
<!-- It makes sense to choose a blank with a minimum number of candidates. 
  -->
For this blank position we 
we try to <em>recursively</em> solve <code>sud</code>, once for each possible candidate; in each recursive case we update the
blank cell with a candidate. The first recursive attempt that
does not give <code>Nothing</code> provides our solution. But if none of the recursive attempts succeed, we return
<code>Nothing</code>.
</p><p>
This method of problem solving is called
<a href="http://en.wikipedia.org/wiki/Backtracking">backtracking</a>.


</p><h3>Assignment F</h3>

<div class="assignment">
<b>F1.</b> Implement a function:
<pre>solve :: Sudoku -&gt; Maybe Sudoku</pre>
using the above idea.
<p>
Examples:
</p><pre class="interactive"><code>printSudoku (fromJust (solve allBlankSudoku))</code>
123456789
456789123
789123456
214365897
365897214
897214365
531642978
642978531
978531642
</pre>
<pre class="interactive"><code>sud &lt;- readSudoku "example.sud"</code>
<code>printSudoku (fromJust (solve sud))</code>
364871295
752936184
819254736
596713428
431582679
278469351
645328917
983147562
127695843
<b>*Sudoku&gt;</b> <em>sud &lt;- readSudoku "impossible.sud"</em>
<code>solve sud</code>
Nothing
</pre>
<p>(In the above examples, we use the standard function <code>fromJust</code> from the library
<code>Data.Maybe</code>.)
</p></div>

<div class="assignment">
<b>F2.</b> For your own convenience, define a function:

  <pre>readAndSolve :: FilePath -&gt; IO ()</pre>
  
that produces instructions for reading the Sudoku from the given file, solving it, and printing the answer.
<p>
Examples:
</p><pre class="interactive"><code>readAndSolve "example.sud"</code>
364871295
752936184
819254736
596713428
431582679
278469351
645328917
983147562
127695843
<code>readAndSolve "impossible.sud"</code>
(no solution)
</pre>
</div>

<div class="assignment">
<b>F3.</b> Implement a function:

  <pre>isSolutionOf :: Sudoku -&gt; Sudoku -&gt; Bool</pre>
  
that checks, given two Sudokus, whether the first one is a solution (i.e. all blocks
are okay, there are no blanks), and also whether the first one is a solution of the
second one (i.e. all digits in the second sudoku are maintained in the first one).
<p>
Examples:
</p><pre class="interactive"><code>fromJust (solve allBlankSudoku) `isSolutionOf` allBlankSudoku</code>
True
<code>allBlankSudoku `isSolutionOf` allBlankSudoku</code>
False
<code>fromJust (solve allBlankSudoku) `isSolutionOf` example</code>
False
</pre>
</div>

<div class="assignment">
<b>F4.</b> Define a property:

  <pre>prop_SolveSound :: Sudoku -&gt; Property</pre>
  
that says that the function <code>solve</code> is <em>sound</em>. Soundness means that every
supposed solution
produced by <code>solve</code> actually is a valid solution of the original problem.
</div>

<h3>Hints</h3>

All the work we did in the assignments A -- E
should be used in order to implement the function <code>solve</code>.

<p>

QuickChecking the property <code>prop_SolveSound</code> will probably take a long time. Be patient!
Alternatively, there are a number of things you can do about this.

</p><ul>
<li><p>You can test on fewer examples (using the QuickCheck function
quickCheckWith). You can for example define:
<!-- 
 <B>check</B> and
the type <B>Config</B>). You can for example define (using QuickCheck 1.x):
<pre>
  fewerCheck prop = check defaultConfig{ configMaxTest = 20 } prop
</pre>
or with QuickCheck 2.x: 
 -->
</p><pre>fewerChecks prop = quickCheckWith stdArgs{ maxSuccess = 30 } prop</pre>
  
and then write <code>fewerChecks prop_SolveSound</code> when you want to QuickCheck the property.
</li><li><p>You can also generate Sudokus with a different probability distribution. Try increasing
the amount of digits in an arbitrary Sudoku by fiddling with the frequencies in the <code>cell</code> function
from Assignment C1 and see what happens.
</p></li><li><p>You can use a compiler, such as <a href="http://www.haskell.org/ghc">GHC</a>. 
</p></li></ul>
<p>It is okay if you do not find a completely satisfactory solution to this issue.

</p><p>Here are some useful functions:

</p><pre>fromJust    :: Maybe a -&gt; a
listToMaybe :: [a] -&gt; Maybe a
catMaybes   :: [Maybe a] -&gt; [a]
</pre>

<p>Here is an example of an impossible Sudoku:

</p><ul>
<li><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/impossible.sud">impossible.sud</a>
</li></ul>

<!-- ==================================================================== -->

<h2>Extra Assignments (for fun)</h2>

Just for fun. You can choose freely whether to do 0, 1 or more of these.
Don't expect us to spend time grading these however. 
There are no perfect, pre-defined answers here.

<ul>
<li><a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/3/extra.shtml">Bring it on!</a>
</li></ul>

<!-- ==================================================================== -->

<h2 id="note">Submission</h2>

Submit your solutions using the Fire system.

<p>Your submission should consist of the following file:

</p><ul>
<li><b>Sudoku.hs</b>, containing your solution. 
It should contain enough comments to understand what is going 
on.
</li></ul>

<!-- <P>

<TABLE WIDTH='100%'><TR BGCOLOR="#DDDDDD"><TD>
<B>Note:</B> You do NOT have to use zip/gzip/tar/bzip on your files! We 
have switched this Fire "feature" off. Just upload and then submit each 
file that is part of your solution.
</TD></TR></TABLE>

<P>
-->

Before you submit your code, Clean It Up! Remember, submitting clean code
is Really Important, and simply the polite thing to do.
After you feel you are done,
spend some time on cleaning your code; make it simpler,
remove unneccessary things, etc.
We will reject your solution if it is not clean. Clean code:

<ul>
<li>Does not have long lines (&lt; 78 characters)
</li><li>Has a consistent layout
</li><li>Has type signatures for all top-level functions
</li><li>Has good comments
</li><li>Has no junk (junk is unused code, commented code, unneccessary comments)
</li><li>Has no overly complicated function definitions
</li><li>Does not contain any repetitive code (copy-and-paste programming)
</li></ul>

<p>

<a href="http://www.cse.chalmers.se/edu/course/TDA452_Functional_Programming/labs/fire.shtml"><b>To the Fire System</b></a>

</p><p>Good Luck!

</p></main>
<footer class="center">
<address>
<!-- hhmts start -->Last modified: Wed Nov  2 17:29:49 CET 2016 <!-- hhmts end -->
by <a href="http://www.cse.chalmers.se/~hallgren/">Thomas Hallgren</a>
</address>
Lab originally written and developed by 
<a href="http://www.cse.chalmers.se/~koen/">Koen Lindström Claessen</a>
</footer>
</body></html>